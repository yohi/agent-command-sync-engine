---
yamlspec_id: SYNC-ENGINE-001
title: AIエージェント・カスタムコマンド統合同期エンジン
status: Draft
created_at: 2025-10-25T10:28:01+09:00
---
# 1. 概要と目標 (Overview & Goal)

## 1.1. 解決すべき中心的な問題 (Core Problem)

- 複数のAIエージェント（ClaudeCode, Codex, GeminiCLI）が独自のコマンドシステムを持つため、開発者は同じ目的のコマンドを再定義する必要があり、非効率性と認知負荷が増大している。
- 主な技術的障壁は、(1) ファイルフォーマットの非互換性（.md vs .toml）、(2) 構文の不一致（引数・シェル実行）、(3) スコープの非対称性（特にCodexがプロジェクトレベル非対応）、(4) SuperClaudeのようなサードパーティ製コマンドの統合の難しさである。

## 1.2. 提案する解決策 (Proposed Solution)

- 「中央リポジトリと同期エンジン」アプローチを採用する。
- 普遍的なソースフォーマット（拡張YAMLフロントマターを持つMarkdown）でコマンドを定義する。
- このソースから、各エージェント固有のフォーマット、構文、スコープルールに準拠したコマンドファイルをプログラム的に変換・生成・配備（デプロイ）する「同期エンジン」を構築する。
- サードパーティ製コマンドは、一度インストールさせた後に中央リポジトリに「取り込む」ワークフローを確立する。

## 1.3. 成功指標 (Success Metrics)

- **一貫性の担保:** エージェント間で挙動が異なるコマンドによるエラー報告数がゼロになる。

# 2. ユーザーペルソナとユーザーストーリー (User Personas & Stories)

## 2.1. 対象ペルソナ (Target Personas)

- **ペルソナ:** ポリ・エージェント開発者
- **詳細:** ClaudeCode, Codex, GeminiCLIなど、複数の特化したAIエージェントCLIを日常的に使い分けるソフトウェア開発者。

## 2.2. ユーザーストーリー (User Stories)

- **(最優先)** **サードパーティ統合:**
  「**開発者として**、SuperClaude のようなサードパーティ製フレームワークをインストールした際、**そのコマンドも統一管理システムに取り込みたい**。**なぜなら**、手動でのコピーや変換なしに、可能な限り他のエージェントでも（互換性のある範囲で）利用したいからだ。」

# 3. 機能要件と受け入れ基準 (Functional Requirements & Acceptance Criteria)

## 3.1. 主要な要件 (Key Requirements)

1.  **ラッパースクリプトの提供:** サードパーティ製フレームワークのインストールとコマンド取り込みプロセス全体を自動化する、マスターセットアップスクリプト（例: `setup-environment.sh`）を提供しなければならない。
2.  **インストーラーの実行:** ラッパースクリプトは、まず SuperClaude のようなフレームワークの標準インストールコマンド（例: `pipx install SuperClaude && SuperClaude install`）を呼び出さなければならない。
3.  **コマンドの取り込み（Ingest）:** インストール完了後、スクリプトはフレームワークが配置したコマンドディレクトリ（例: `~/.claude/commands/sc/`）をスキャンし、検出したコマンドファイル（例: `.md` ファイル）を、中央リポジトリ内の専用ディレクトリ（例: `central-commands/_frameworks/superclaude/`）にコピーしなければならない。
4.  **同期の実行トリガー:** コマンドの取り込み完了後、ラッパースクリプトはメインの同期エンジン（第3章で設計したもの）を自動的に実行し、取り込んだコマンドを含む全ての中央リポジトリのコマンドを各エージェント用に変換・配備しなければならない。

## 3.2. 受け入れ基準 (Acceptance Criteria)

```gherkin
フィーチャー: サードパーティ製コマンドの統合

シナリオ: 開発者がSuperClaudeフレームワークをインストールし、統一管理下に置く
  前提（Given）: 開発者は「中央コマンドリポジトリ」をクローンしており、"SuperClaude" はまだインストールされていない
  かつ（And）: 中央リポジトリの `frameworks/superclaude/` ディレクトリは空である
  
  もし（When）: 開発者が `./setup-environment.sh`（ラッパースクリプト）を実行する
  
  ならば（Then）: "SuperClaude" のインストールコマンドが実行される
  かつ（And）: SuperClaude によって `~/.claude/commands/sc/plan.md` がインストールされる
  かつ（And）: 中央リポジトリの `frameworks/superclaude/sc/plan.md` に、上記ファイルがコピー（取り込み）される
  かつ（And）: メインの同期エンジンが実行され、`~/.codex/prompts/sc/plan.md`（Codex用）が生成・配備される
  かつ（And）: メインの同期エンジンが実行され、`~/.gemini/commands/sc:plan.toml`（Gemini用）が（ベストエフォートで）生成・配備される
````

# 4. 制約と境界 (Constraints & Boundaries)

## 4.1. 技術的制約 (Technical Constraints)

  - **Codex CLI のスコープ**: 現状の Codex CLI はプロジェクトレベルのスコープをサポートしていない。同期エンジンは、当面すべての Codex 用コマンドをユーザーレベル (`~/.codex/prompts/`) に配備する必要がある。
  - **サードパーティの互換性**: SuperClaude のようなサードパーティ製コマンドは、ClaudeCode 固有の構文や機能に依存している可能性がある。同期エンジンが他のエージェント（特に Gemini）用に変換したコマンドの完全な動作は保証されない。

## 4.2. 非目標 (Non-Goals)

  - **MCPサーバーの実装**: このフェーズでは、ローカルMCP（Model Context Protocol）サーバー の構築は行わない。これは「フェーズ2」または将来的な代替案 と位置付ける。
  - **シンボリックリンクアプローチ**: シンボリックリンクによるコマンド共有は、非互換性を解決できないため採用しない。
  - **完璧な自動変換**: 取り込まれたサードパーティ製コマンドの完璧な自動変換は保証しない。同期エンジンはあくまでベストエフォートでの変換（ソース素材の提供）を行い、最終的な調整（特に Gemini の .toml ファイル）は開発者による手動介入が必要であることを前提とする。

# 5. 技術提案（AI生成）

### 5.1. 要件分析サマリー

本「同期エンジン」の技術選定において、以下の要件が最重要であると判断した。

1.  **多様なファイル形式の操作**: 普遍的ソース（YAMLフロントマター + Markdown） を解析し、Markdown (.md) と TOML (.toml) という2つの異なる形式を出力する必要がある。
2.  **高度な文字列（構文）変換**: エージェント固有の構文（例: `{ARGS}` を `$ARGUMENTS` や `{{args}}` に、`{SHELL:cmd}` を `\!cmd` や `\!{cmd}` に）置換するため、堅牢なテキスト処理（正規表現など）が必要である。
3.  **複雑なファイルシステム操作**: ユーザーレベルとプロジェクトレベルのスコープ、および Gemini の名前空間（例: `git/commit.toml` を `/git:commit`）に対応するため、ホームディレクトリの解決や再帰的なディレクトリ走査・作成を安全に行う必要がある。
4.  **外部プロセス実行**: 要件3.1に基づき、ラッパースクリプトが `pipx` や `SuperClaude install` などの外部コマンドを確実に実行し、制御する必要がある。

### 5.2. 候補スタックの比較

| 評価基準 | 候補1: Python | 候補2: Node.js (TypeScript) |
| :--- | :--- | :--- |
| **スケーラビリティ** | CLIツールとして十分以上 | CLIツールとして十分以上 |
| **開発者エコシステム** | 非常に成熟。データ処理・スクリプティング分野で優位。 | 非常に成熟。Web・フロントエンド開発者になじみ深い。 |
| **学習曲線** | 構文が平易で、システム管理スクリプトの記述に優れる。 | JavaScript/TypeScript開発者にとっては学習コストゼロ。 |
| **推定運用コスト** | 低（ランタイム依存のみ） | 低（ランタイム依存のみ） |
| **ライブラリ（要件適合度）** | **非常に高い**。<br>・`pathlib` (標準): ファイルパス操作<br>・`subprocess` (標準): 外部プロセス実行<br>・`PyYAML`: YAML解析<br>・`toml`: TOML生成 | **高い**。<br>・`fs/promises` (標準): ファイルパス操作<br>・`execa`: 外部プロセス実行<br>・`yaml`: YAML解析<br>・`@ltd/j-toml`: TOML生成 |

### 5.3. 最終提案と論理的根拠

**主たる推薦案: Python**

添付レポートの第5.2章 で既に `sync.py` としての実装例が示されている点も踏まえ、**Python** を本同期エンジンの実装言語として強く推奨する。

  - **プログラミング言語: Python 3.10+**

      - **選定理由:** 要件分析で特定されたすべてのタスク（ファイル形式操作、文字列処理、ファイルシステム操作、外部プロセス実行）に対し、Pythonは標準ライブラリ（`pathlib`, `subprocess`, `re`）またはデファクトスタンダード（`PyYAML`, `toml`）で、最も直感的かつ堅牢なソリューションを提供する。特に `pathlib` は、`~/.claude/commands/` のような複雑なパス操作をOS非依存で安全に記述することに長けている。

  - **Webフレームワーク: N/A**

      - **選定理由:** 本プロジェクトはCLIツールであり、Webサーバー機能は「非目標（Non-Goals）」 のMCPサーバーフェーズまで不要である。

  - **データベース: N/A**

      - **選定理由:** 状態はすべてファイルシステム（中央リポジトリのソースファイル） に保持されるため、データベースは不要である。

  - **その他主要ライブラリ:**

      - **`Typer` (または `Click`)**: （推奨）レポートで要求される `--scope=user` や `setup-environment.sh` のようなラッパー機能を、単一のPythonスクリプト内で `sync` コマンドや `setup` コマンドとしてエレガントに実装するために推奨される。
      - **`PyYAML`**: 普遍的コマンドソースのYAMLフロントマター を解析するために必須。
      - **`toml`**: Gemini CLI 向けの `.toml` ファイルを生成するために必須。

